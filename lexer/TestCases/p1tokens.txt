program <PROGRAM_KW,->
prg1 <IDENTIFIER, 1>
; <SEMICOLON, ->
integer <INTEGER_KW,->
num <IDENTIFIER, 2>
, <COMMA, ->
divisor <IDENTIFIER, 3>
, <COMMA, ->
quotient <IDENTIFIER, 4>
; <SEMICOLON, ->
begin <BEGIN_KW, ->
num <IDENTIFIER, 2>
:= <ASSIGN_OP, ->
61 <INTEGER_NUMBER, 5>
; <SEMICOLON, ->
divisor <IDENTIFIER, 3>
:= <ASSIGN_OP, ->
2 <INTEGER_NUMBER, 6>
; <SEMICOLON, ->
quotient <IDENTIFIER, 4>
:= <ASSIGN_OP, ->
0 <INTEGER_NUMBER, 7>
; <SEMICOLON, ->
if <IF_KW, ->
num <IDENTIFIER, 2>
= <EQ_OP, ->
1 <INTEGER_NUM, 8>
then <THEN_KW, ->
return <RETURN_KW, ->
false <FALSE_KW, ->
; <SEMICOLON, ->
else <ELSE_KW, ->
if <IF_KW, ->
num <IDENTIFIER, 2>
= <EQ_OP, ->
2 <INTEGER_NUMBER, 6>
then <THEN_KW, ->
return <RETURN_KW, ->
true <TRUE_KW, ->
; <SEMICOLON, ->
while <WHILE_KW, ->
divisor <IDENTIFER, 3>
< <LT_KW, ->
( <LEFT_PA,->
num <IDENTIFIER, 2>
/ <DIV_OP, ->
2 <INTEGER_NUM, 6>
) <RIGHT_PA,->
do <DO_KW, ->
begin <BEGIN_KW, ->
quotient <IDENTIFIER, 4>
:= <ASSIGN_OP, ->
num <IDENTIFIER, 2>
/ <DIV_OP, ->
divisor <IDENTIFER, 3>
; <SEMICOLON, ->
if <IF_KW, ->
divisor <IDENTIFER, 3>
* <MUL_OP, ->
quotient <IDENTIFIER, 4>
= <EQ_OP, ->
num <IDENTIFIER, 2>
then <THEN_KW, ->
return <RETURN_KW, ->
false <FALSE_KW, ->
; <SEMICOLON, ->
divisor <IDENTIFER, 3>
:= <ASSIGN_OP, ->
divisor <IDENTIFER, 3>
+ <ADD_OP, ->
1 <INTEGER_NUMBER, 9>
; <SEMICOLON, ->
end <END_KW, ->
return <RETURN_KW, ->
; <SEMICOLON, ->
end <END_KW, ->
